"""
Type stub file for EvrmoreClient to provide intellisense for Evrmore commands.
This file doesn't change the implementation but helps IDEs recognize available methods.
"""

from typing import Any, Dict, List, Optional, Union, Tuple, TypeVar, Type, cast, Callable, overload, AsyncContextManager, ContextManager
import asyncio
from pathlib import Path
from decimal import Decimal

from evrmore_rpc.models import (
    BlockchainInfo, Block, BlockHeader, ChainTip, MempoolInfo, 
    TxOut, TxOutSetInfo, AssetInfo, AssetData, CacheInfo, ListAssetResult,
    NetworkInfo, PeerInfo, LocalAddress, Network, MiningInfo, MiningStats,
    AddressBalance, AddressDelta, AddressUtxo, AddressMempool,
    DecodedTransaction, DecodedScript, TransactionInput, TransactionOutput,
    WalletInfo, WalletTransaction, UnspentOutput
)

from evrmore_rpc.utils import AwaitableResult

T = TypeVar('T')  # Generic type for client
R = TypeVar('R')  # Return type

class EvrmoreRPCError(Exception):
    """Exception raised when an RPC command fails."""
    pass

class EvrmoreConfig:
    def __init__(self, datadir: Optional[Union[str, Path]] = None, testnet: bool = False): ...
    def get(self, key: str, default: Any = None) -> Any: ...
    def get_rpc_credentials(self) -> Tuple[Optional[str], Optional[str]]: ...
    def get_rpc_connection_info(self) -> Tuple[str, int]: ...
    def get_zmq_endpoints(self) -> Dict[str, str]: ...
    def get_zmq_hwm(self) -> Dict[str, int]: ...
    def get_p2p_connection_info(self) -> Tuple[str, int]: ...
    def is_server_enabled(self) -> bool: ...
    def is_index_enabled(self, index_name: str) -> bool: ...
    def get_all(self) -> Dict[str, Any]: ...
    def __getitem__(self, key: str) -> Any: ...
    def __contains__(self, key: str) -> bool: ...

class EvrmoreClient(ContextManager["EvrmoreClient"], AsyncContextManager["EvrmoreClient"]):
    def __init__(self, 
                 url: Optional[str] = None,
                 datadir: Optional[Union[str, Path]] = None,
                 rpcuser: Optional[str] = None,
                 rpcpassword: Optional[str] = None,
                 rpcport: Optional[int] = None,
                 testnet: bool = False,
                 timeout: int = 30,
                 async_mode: Optional[bool] = None): ...
    
    def initialize(self) -> Union[None, asyncio.coroutine]: ...
    def execute_command(self, command: str, *args: Any) -> Any: ...
    def reset(self): ...
    def close_sync(self): ...
    async def close(self): ...
    
    # Blockchain methods
    def getbestblockhash(self) -> Union[str, AwaitableResult[str]]: ...
    def getblock(self, blockhash: str, verbosity: int = 1) -> Union[Union[str, Dict[str, Any], Block], AwaitableResult[Union[str, Dict[str, Any], Block]]]: ...
    def getblockchaininfo(self) -> Union[BlockchainInfo, AwaitableResult[BlockchainInfo]]: ...
    def getblockcount(self) -> Union[int, AwaitableResult[int]]: ...
    def getblockhash(self, height: int) -> Union[str, AwaitableResult[str]]: ...
    def getblockheader(self, blockhash: str, verbose: bool = True) -> Union[Union[str, BlockHeader], AwaitableResult[Union[str, BlockHeader]]]: ...
    def getchaintips(self) -> Union[List[ChainTip], AwaitableResult[List[ChainTip]]]: ...
    def getdifficulty(self) -> Union[float, AwaitableResult[float]]: ...
    def getmempoolinfo(self) -> Union[MempoolInfo, AwaitableResult[MempoolInfo]]: ...
    def getrawmempool(self, verbose: bool = False) -> Union[Union[List[str], Dict[str, Any]], AwaitableResult[Union[List[str], Dict[str, Any]]]]: ...
    def gettxout(self, txid: str, n: int, include_mempool: bool = True) -> Union[Optional[TxOut], AwaitableResult[Optional[TxOut]]]: ...
    def gettxoutsetinfo(self) -> Union[TxOutSetInfo, AwaitableResult[TxOutSetInfo]]: ...
    def verifychain(self, checklevel: int = 3, nblocks: int = 6) -> Union[bool, AwaitableResult[bool]]: ...
    
    # Asset methods
    def getassetdata(self, asset_name: str) -> Union[AssetData, AwaitableResult[AssetData]]: ...
    def getcacheinfo(self) -> Union[CacheInfo, AwaitableResult[CacheInfo]]: ...
    def listassets(self, asset: str = "*", verbose: bool = False, count: int = 100, start: int = 0) -> Union[Union[List[str], List[ListAssetResult]], AwaitableResult[Union[List[str], List[ListAssetResult]]]]: ...
    def listmyassets(self, asset: str = "*", verbose: bool = False, count: int = 100, start: int = 0) -> Union[Dict[str, Any], AwaitableResult[Dict[str, Any]]]: ...
    def issue(self, asset_name: str, qty: Union[int, float, Decimal], to_address: Optional[str] = None, change_address: Optional[str] = None, units: int = 0, reissuable: bool = True, has_ipfs: bool = False, ipfs_hash: Optional[str] = None) -> Union[Dict[str, Any], AwaitableResult[Dict[str, Any]]]: ...
    def issueunique(self, root_name: str, asset_tags: List[str], to_address: Optional[str] = None, change_address: Optional[str] = None, has_ipfs: bool = False, ipfs_hash: Optional[str] = None) -> Union[Dict[str, Any], AwaitableResult[Dict[str, Any]]]: ...
    def reissue(self, asset_name: str, qty: Union[int, float, Decimal], to_address: str, change_address: Optional[str] = None, reissuable: bool = True, new_units: int = -1, new_ipfs: Optional[str] = None) -> Union[Dict[str, Any], AwaitableResult[Dict[str, Any]]]: ...
    def transfer(self, asset_name: str, qty: Union[int, float, Decimal], to_address: str) -> Union[Dict[str, Any], AwaitableResult[Dict[str, Any]]]: ...
    
    # Network methods
    def getnetworkinfo(self) -> Union[NetworkInfo, AwaitableResult[NetworkInfo]]: ...
    def getpeerinfo(self) -> Union[List[PeerInfo], AwaitableResult[List[PeerInfo]]]: ...
    def getconnectioncount(self) -> Union[int, AwaitableResult[int]]: ...
    def ping(self) -> Union[None, AwaitableResult[None]]: ...
    
    # Mining methods
    def getmininginfo(self) -> Union[MiningInfo, AwaitableResult[MiningInfo]]: ...
    def getnetworkhashps(self, nblocks: int = 120, height: int = -1) -> Union[float, AwaitableResult[float]]: ...
    def prioritisetransaction(self, txid: str, priority_delta: float, fee_delta: int) -> Union[bool, AwaitableResult[bool]]: ...
    def submitblock(self, hexdata: str, jsonparametersobject: Optional[Dict[str, Any]] = None) -> Union[Optional[str], AwaitableResult[Optional[str]]]: ...
    
    # Address index methods
    def getaddressbalance(self, addresses: Union[str, List[str]]) -> Union[AddressBalance, AwaitableResult[AddressBalance]]: ...
    def getaddressdeltas(self, addresses: Union[str, List[str]], start: Optional[int] = None, end: Optional[int] = None) -> Union[List[AddressDelta], AwaitableResult[List[AddressDelta]]]: ...
    def getaddressutxos(self, addresses: Union[str, List[str]]) -> Union[List[AddressUtxo], AwaitableResult[List[AddressUtxo]]]: ...
    def getaddressmempool(self, addresses: Union[str, List[str]]) -> Union[List[AddressMempool], AwaitableResult[List[AddressMempool]]]: ...
    
    # Raw transaction methods
    def createrawtransaction(self, inputs: List[Dict[str, Any]], outputs: Dict[str, Any], locktime: int = 0, replaceable: bool = False) -> Union[str, AwaitableResult[str]]: ...
    def decoderawtransaction(self, hexstring: str) -> Union[DecodedTransaction, AwaitableResult[DecodedTransaction]]: ...
    def decodescript(self, hexstring: str) -> Union[DecodedScript, AwaitableResult[DecodedScript]]: ...
    def getrawtransaction(self, txid: str, verbose: bool = False) -> Union[Union[str, Dict[str, Any]], AwaitableResult[Union[str, Dict[str, Any]]]]: ...
    def sendrawtransaction(self, hexstring: str, allowhighfees: bool = False) -> Union[str, AwaitableResult[str]]: ...
    def signrawtransaction(self, hexstring: str, prevtxs: Optional[List[Dict[str, Any]]] = None, privkeys: Optional[List[str]] = None, sighashtype: str = "ALL") -> Union[Dict[str, Any], AwaitableResult[Dict[str, Any]]]: ...
    
    # Wallet methods
    def abandontransaction(self, txid: str) -> Union[None, AwaitableResult[None]]: ...
    def getbalance(self, account: str = "*", minconf: int = 1, include_watchonly: bool = False) -> Union[float, AwaitableResult[float]]: ...
    def getnewaddress(self, account: str = "") -> Union[str, AwaitableResult[str]]: ...
    def getrawchangeaddress(self) -> Union[str, AwaitableResult[str]]: ...
    def getreceivedbyaddress(self, address: str, minconf: int = 1) -> Union[float, AwaitableResult[float]]: ...
    def gettransaction(self, txid: str, include_watchonly: bool = False) -> Union[WalletTransaction, AwaitableResult[WalletTransaction]]: ...
    def getunconfirmedbalance(self) -> Union[float, AwaitableResult[float]]: ...
    def getwalletinfo(self) -> Union[WalletInfo, AwaitableResult[WalletInfo]]: ...
    def importaddress(self, address: str, label: str = "", rescan: bool = True, p2sh: bool = False) -> Union[None, AwaitableResult[None]]: ...
    def importprivkey(self, privkey: str, label: str = "", rescan: bool = True) -> Union[None, AwaitableResult[None]]: ...
    def importpubkey(self, pubkey: str, label: str = "", rescan: bool = True) -> Union[None, AwaitableResult[None]]: ...
    def importwallet(self, filename: str) -> Union[None, AwaitableResult[None]]: ...
    def listaddressgroupings(self) -> Union[List[List[List[Any]]], AwaitableResult[List[List[List[Any]]]]]: ...
    def listlockunspent(self) -> Union[List[Dict[str, Any]], AwaitableResult[List[Dict[str, Any]]]]: ...
    def listreceivedbyaddress(self, minconf: int = 1, include_empty: bool = False, include_watchonly: bool = False) -> Union[List[Dict[str, Any]], AwaitableResult[List[Dict[str, Any]]]]: ...
    def listsinceblock(self, blockhash: Optional[str] = None, target_confirmations: int = 1, include_watchonly: bool = False, include_removed: bool = True) -> Union[Dict[str, Any], AwaitableResult[Dict[str, Any]]]: ...
    def listtransactions(self, account: str = "*", count: int = 10, skip: int = 0, include_watchonly: bool = False) -> Union[List[Dict[str, Any]], AwaitableResult[List[Dict[str, Any]]]]: ...
    def listunspent(self, minconf: int = 1, maxconf: int = 9999999, addresses: Optional[List[str]] = None, include_unsafe: bool = True, query_options: Optional[Dict[str, Any]] = None) -> Union[List[UnspentOutput], AwaitableResult[List[UnspentOutput]]]: ...
    def lockunspent(self, unlock: bool, transactions: Optional[List[Dict[str, Any]]] = None) -> Union[bool, AwaitableResult[bool]]: ...
    def sendfrom(self, fromaccount: str, toaddress: str, amount: Union[int, float, Decimal], minconf: int = 1, comment: str = "", comment_to: str = "") -> Union[str, AwaitableResult[str]]: ...
    def sendmany(self, fromaccount: str, amounts: Dict[str, Union[int, float, Decimal]], minconf: int = 1, comment: str = "", subtractfeefrom: Optional[List[str]] = None, replaceable: bool = False, conf_target: int = 1, estimate_mode: str = "UNSET") -> Union[str, AwaitableResult[str]]: ...
    def sendtoaddress(self, address: str, amount: Union[int, float, Decimal], comment: str = "", comment_to: str = "", subtractfeefromamount: bool = False, replaceable: bool = False, conf_target: int = 1, estimate_mode: str = "UNSET") -> Union[str, AwaitableResult[str]]: ...
    def signmessage(self, address: str, message: str) -> Union[str, AwaitableResult[str]]: ...
    def walletlock(self) -> Union[None, AwaitableResult[None]]: ...
    def walletpassphrase(self, passphrase: str, timeout: int) -> Union[None, AwaitableResult[None]]: ...
    def walletpassphrasechange(self, oldpassphrase: str, newpassphrase: str) -> Union[None, AwaitableResult[None]]: ... 